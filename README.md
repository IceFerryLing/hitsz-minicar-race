# STM32æ™ºèƒ½å¾ªè¿¹å°è½¦æŽ§åˆ¶ç³»ç»Ÿ

åŸºäºŽSTM32çš„æ™ºèƒ½å°è½¦æŽ§åˆ¶ç³»ç»Ÿï¼Œå®žçŽ°ç²¾ç¡®çš„å¾ªè¿¹ã€å§¿æ€æŽ§åˆ¶å’Œé€Ÿåº¦è°ƒèŠ‚åŠŸèƒ½ã€‚é¡¹ç›®ä½¿ç”¨å¤šä¼ æ„Ÿå™¨èžåˆæŽ§åˆ¶ç­–ç•¥ï¼ŒåŒ…æ‹¬å…‰ç”µä¼ æ„Ÿå™¨ã€é™€èžºä»ªå’Œç¼–ç å™¨ã€‚

## åŠŸèƒ½ç‰¹æ€§

### ðŸš— æ ¸å¿ƒåŠŸèƒ½
- **ç²¾ç¡®å¾ªè¿¹æŽ§åˆ¶**ï¼šä½¿ç”¨12è·¯å…‰ç”µä¼ æ„Ÿå™¨è¿›è¡Œçº¿è·¯æ£€æµ‹
- **ä¸‰é‡PIDæŽ§åˆ¶**ï¼šè½¬å‘çŽ¯ + é€Ÿåº¦çŽ¯ + è§’é€Ÿåº¦çŽ¯çš„å¤šå±‚æŽ§åˆ¶æž¶æž„
- **å§¿æ€ç¨³å®š**ï¼šé›†æˆBMI270é™€èžºä»ªè¿›è¡Œè§’åº¦å’Œè§’é€Ÿåº¦æµ‹é‡
- **ç¼–ç å™¨åé¦ˆ**ï¼šå®žæ—¶ç›‘æµ‹ç”µæœºé€Ÿåº¦å®žçŽ°é—­çŽ¯æŽ§åˆ¶
- **è‡ªé€‚åº”å¯»çº¿**ï¼šæ”¯æŒè™šçº¿ã€å¼¯é“ç­‰å¤æ‚è·¯å¾„å¤„ç†

### ðŸŽ›ï¸ æŽ§åˆ¶ç­–ç•¥
- **è½¬å‘çŽ¯**ï¼šåŸºäºŽå…‰ç”µä¼ æ„Ÿå™¨åå·®çš„PDæŽ§åˆ¶
- **é€Ÿåº¦çŽ¯**ï¼šåŸºäºŽç¼–ç å™¨åé¦ˆçš„PIæŽ§åˆ¶
- **è§’é€Ÿåº¦çŽ¯**ï¼šåŸºäºŽé™€èžºä»ªçš„PDæŽ§åˆ¶ï¼Œæé«˜è½¬å‘ç¨³å®šæ€§

## æŽ§åˆ¶æµç¨‹

### 1. å®šæ—¶å™¨ä¸­æ–­è§¦å‘æŽ§åˆ¶å‘¨æœŸ
```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM2) { /* ä½¿ç”¨TIM2ä½œä¸ºæŽ§åˆ¶å‘¨æœŸ*/
        PID_Control();
    }
}
```
- **é¢‘çŽ‡**: 1kHzï¼ˆTIM2é…ç½®ï¼šé¢„åˆ†é¢‘71ï¼Œå‘¨æœŸ999ï¼‰
- **ä½œç”¨**: æ¯1msæ‰§è¡Œä¸€æ¬¡å®Œæ•´çš„PIDæŽ§åˆ¶å¾ªçŽ¯

### 2. ä¸»PIDæŽ§åˆ¶æµç¨‹
```c
void PID_Control(void)
{
    /* æ­¥éª¤1: è¯»å–ä¼ æ„Ÿå™¨æ•°æ® */
    Update_Gyro_Data();                    // æ›´æ–°é™€èžºä»ªæ•°æ®
    float current_deviation = Calculate_Deviation();  // è®¡ç®—å…‰ç”µåå·®
    
    /* æ­¥éª¤2: è¯»å–ç¼–ç å™¨å€¼ */
    left_encoder = __HAL_TIM_GET_COUNTER(&htim4);
    right_encoder = __HAL_TIM_GET_COUNTER(&htim3);
    
    /* æ­¥éª¤3: è½¬å‘çŽ¯æŽ§åˆ¶ */
    float turn_output = KP_turn * current_deviation + 
                       KD_turn * (current_deviation - last_deviation);
    last_deviation = current_deviation;
    
    /* æ­¥éª¤4: è§’é€Ÿåº¦çŽ¯æŽ§åˆ¶ */
    target_gyro_rate = turn_output;  // è½¬å‘çŽ¯è¾“å‡ºä½œä¸ºç›®æ ‡è§’é€Ÿåº¦
    float gyro_output = Gyro_Rate_Control(target_gyro_rate, gyro_z);
    
    /* æ­¥éª¤5: é€Ÿåº¦åˆ†é… */
    float left_target = 500.0f - gyro_output;  // åŸºç¡€é€Ÿåº¦500ï¼Œå®žé™…éœ€è°ƒæ•´
    float right_target = 500.0f + gyro_output;
    
    /* æ­¥éª¤6: é€Ÿåº¦çŽ¯æŽ§åˆ¶ */
    // ç¼–ç å™¨å·®å€¼è®¡ç®—é€Ÿåº¦ï¼ˆç®€åŒ–å¤„ç†ï¼Œå®žé™…åº”è®¡ç®—çœŸå®žé€Ÿåº¦ï¼‰
    float left_error = left_target - left_speed;
    float right_error = right_target - right_speed;
    
    left_integral += left_error;    // ç§¯åˆ†é¡¹
    right_integral += right_error;
    
    // ç§¯åˆ†é™å¹…
    if(left_integral > 1000) left_integral = 1000;
    if(left_integral < -1000) left_integral = -1000;
    if(right_integral > 1000) right_integral = 1000;  
    if(right_integral < -1000) right_integral = -1000;
    
    /* æ­¥éª¤7: è®¡ç®—PWMè¾“å‡º */
    left_pwm = KP_speed * left_error + KI_speed * left_integral;
    right_pwm = KP_speed * right_error + KI_speed * right_integral;
    
    /* æ­¥éª¤8: é©±åŠ¨ç”µæœº */
    Motor_Control(left_pwm, right_pwm);
}
```

### 3. ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†æµç¨‹

#### 3.1 å…‰ç”µä¼ æ„Ÿå™¨æ•°æ®èŽ·å–
```c
float Calculate_Deviation(void)
{
    uint16_t mux_value;
    MUX_get_value(&mux_value);  // èŽ·å–å¤šè·¯å¤ç”¨å™¨å€¼
    
    float deviation = 0;
    int count = 0;
    
    /* éåŽ†12ä¸ªå…‰ç”µç®¡ */
    for(int i = 0; i < 12; i++) {
        if(MUX_GET_CHANNEL(mux_value, i)) {
            deviation += phototube_weights[i];  // åŠ æƒæ±‚å’Œ
            count++;
        }
    }
    
    /* å¤„ç†ä¸åŒæƒ…å†µ */
    if(count > 0) {
        deviation = deviation / count;  // è®¡ç®—å¹³å‡åå·®
    } else {
        /* ä¸¢çº¿å¤„ç† */
        if(last_deviation > 3.0f) deviation = 8.0f;
        else if(last_deviation < -3.0f) deviation = -8.0f;
        else deviation = -8.0f;
    }
    
    /* é™åˆ¶åå·®èŒƒå›´ */
    if(deviation > 11.0f) deviation = 11.0f;
    if(deviation < -11.0f) deviation = -11.0f;
    
    return deviation;
}
```

#### 3.2 é™€èžºä»ªæ•°æ®æ›´æ–°
```c
void Update_Gyro_Data(void)
{
    /* è¯»å–åŽŸå§‹æ•°æ® */
    dodo_BMI270_get_data();
    
    /* è½¬æ¢ä¸ºè§’é€Ÿåº¦ */
    gyro_z = BMI270_gyro_transition(BMI270_gyro_z);
    
    /* ç§¯åˆ†è®¡ç®—è§’åº¦ */
    uint32_t current_time = HAL_GetTick();
    if(last_gyro_time > 0) {
        float dt = (current_time - last_gyro_time) / 1000.0f;
        integrated_angle += gyro_z * dt;
        
        /* è§’åº¦é™å¹… */
        if(integrated_angle > 180.0f) integrated_angle = 180.0f;
        if(integrated_angle < -180.0f) integrated_angle = -180.0f;
    }
    last_gyro_time = current_time;
}
```

### 4. å¤šçŽ¯æŽ§åˆ¶æž¶æž„è¯¦è§£

#### 4.1 è½¬å‘çŽ¯ï¼ˆå¤–çŽ¯ï¼‰
- **è¾“å…¥**: å…‰ç”µä¼ æ„Ÿå™¨åå·®å€¼ï¼ˆ-11~11ï¼‰
- **è¾“å‡º**: ç›®æ ‡è§’é€Ÿåº¦
- **æŽ§åˆ¶ç®—æ³•**: PDæŽ§åˆ¶
- **å‚æ•°è°ƒèŠ‚**:
  - KP_turn: å½±å“è½¬å‘å“åº”é€Ÿåº¦
  - KD_turn: æŠ‘åˆ¶è¶…è°ƒå’Œéœ‡è¡

#### 4.2 è§’é€Ÿåº¦çŽ¯ï¼ˆä¸­çŽ¯ï¼‰
- **è¾“å…¥**: ç›®æ ‡è§’é€Ÿåº¦ï¼ˆæ¥è‡ªè½¬å‘çŽ¯ï¼‰
- **åé¦ˆ**: å®žé™…è§’é€Ÿåº¦ï¼ˆæ¥è‡ªé™€èžºä»ªï¼‰
- **æŽ§åˆ¶ç®—æ³•**: PDæŽ§åˆ¶
- **ä½œç”¨**: æé«˜è½¬å‘ç¨³å®šæ€§å’ŒåŠ¨æ€å“åº”
- **å‚æ•°è°ƒèŠ‚**:
  - KP_gyro: å½±å“è§’é€Ÿåº¦è·Ÿè¸ªç²¾åº¦
  - KD_gyro: æŠ‘åˆ¶è§’é€Ÿåº¦éœ‡è¡

#### 4.3 é€Ÿåº¦çŽ¯ï¼ˆå†…çŽ¯ï¼‰
- **è¾“å…¥**: ç›®æ ‡é€Ÿåº¦ï¼ˆåŸºç¡€é€Ÿåº¦ Â± è½¬å‘è¡¥å¿ï¼‰
- **åé¦ˆ**: å®žé™…é€Ÿåº¦ï¼ˆæ¥è‡ªç¼–ç å™¨ï¼‰
- **æŽ§åˆ¶ç®—æ³•**: PIæŽ§åˆ¶
- **ä½œç”¨**: ç»´æŒæ’å®šé€Ÿåº¦ï¼Œè¡¥å¿è´Ÿè½½å˜åŒ–
- **å‚æ•°è°ƒèŠ‚**:
  - KP_speed: å½±å“é€Ÿåº¦å“åº”
  - KI_speed: æ¶ˆé™¤ç¨³æ€è¯¯å·®

### 5. ç¡¬ä»¶æž¶æž„

#### 5.1 ä¸»æŽ§åˆ¶å™¨
- **MCU**: STM32ç³»åˆ—ï¼ˆåŸºäºŽHALåº“å¼€å‘ï¼‰
- **æ—¶é’Ÿ**: 72MHzä¸»é¢‘ï¼Œå¤–éƒ¨8MHzæ™¶æŒ¯

#### 5.2 ä¼ æ„Ÿå™¨æ¨¡å—
1. **å…‰ç”µä¼ æ„Ÿå™¨é˜µåˆ—** (12è·¯)
   - å¤šè·¯å¤ç”¨å™¨æŽ§åˆ¶
   - æƒé‡åˆ†é…ï¼š{-11, -9, -7, -5, -3, -1, 1, 3, 5, 7, 9, 11}

2. **å§¿æ€ä¼ æ„Ÿå™¨**
   - BMI270é™€èžºä»ªï¼ˆSPIæŽ¥å£ï¼‰
   - æµ‹é‡èŒƒå›´ï¼šÂ±250Â°/s
   - é‡‡æ ·é¢‘çŽ‡ï¼š100Hz

3. **ç”µæœºç¼–ç å™¨**
   - å·¦å³ç”µæœºç‹¬ç«‹ç¼–ç å™¨
   - TIM3/TIM4ç¼–ç å™¨æ¨¡å¼

#### 5.3 ç”µæœºé©±åŠ¨
- **PWMé¢‘çŽ‡**: 10kHzï¼ˆTIM1ï¼Œé¢„åˆ†é¢‘0ï¼Œå‘¨æœŸ7199ï¼‰
- **æŽ§åˆ¶æ–¹å¼**: åŒHæ¡¥é©±åŠ¨ï¼Œæ”¯æŒæ­£åè½¬
- **æœ€å¤§PWMå€¼**: 1800

#### 5.4 é€šä¿¡æŽ¥å£
- **è°ƒè¯•ä¸²å£**: USART3ï¼Œ115200bps
- **ä¼ æ„Ÿå™¨SPI**: SPI1ï¼ŒBMI270é€šä¿¡

### 6. è½¯ä»¶æž¶æž„

#### 6.1 æ–‡ä»¶ç»“æž„
```
â”œâ”€â”€ Core/
â”‚   â”œâ”€â”€ Src/main.c          # ä¸»æŽ§åˆ¶ç¨‹åº
â”‚   â”œâ”€â”€ Inc/                # å¤´æ–‡ä»¶
â”‚   â””â”€â”€ Startup/            # å¯åŠ¨æ–‡ä»¶
â”œâ”€â”€ Drivers/
â”‚   â”œâ”€â”€ STM32xx_HAL_Driver/ # HALåº“
â”‚   â””â”€â”€ CMSIS/              # Cortexå†…æ ¸æ”¯æŒ
â”œâ”€â”€ BMI270/                 # é™€èžºä»ªé©±åŠ¨
â””â”€â”€ README.md               # é¡¹ç›®è¯´æ˜Ž
```

#### 6.2 ä¸»è¦å‡½æ•°
- `Control_Init(void)`: æŽ§åˆ¶ç³»ç»Ÿåˆå§‹åŒ–
- `dodo_BMI270_init(void)`: é™€èžºä»ªåˆå§‹åŒ–
- `Calculate_Deviation(void)`: è®¡ç®—å…‰ç”µä¼ æ„Ÿå™¨åå·®
- `PID_Control(void)`: ä¸»PIDæŽ§åˆ¶å‡½æ•°
- `Motor_Control(float left, float right)`: ç”µæœºæŽ§åˆ¶
- `Gyro_Rate_Control(float, float)`: è§’é€Ÿåº¦çŽ¯æŽ§åˆ¶
- `Update_Gyro_Data(void)`: æ›´æ–°é™€èžºä»ªæ•°æ®

### 7. å‚æ•°é…ç½®

#### 7.1 PIDå‚æ•°ï¼ˆå¯è°ƒèŠ‚ï¼‰
```c
/* è½¬å‘çŽ¯ */
float KP_turn = 90.0f;      // æ¯”ä¾‹ç³»æ•°
float KD_turn = -60.0f;     // å¾®åˆ†ç³»æ•°

/* é€Ÿåº¦çŽ¯ */
float KP_speed = 30.0f;     // æ¯”ä¾‹ç³»æ•°
float KI_speed = 0.3f;      // ç§¯åˆ†ç³»æ•°

/* è§’é€Ÿåº¦çŽ¯ */
float KP_gyro = 8.0f;       // æ¯”ä¾‹ç³»æ•°
float KD_gyro = 0.08f;      // å¾®åˆ†ç³»æ•°
```

#### 7.2 è¿è¡Œå‚æ•°
```c
#define MOTOR_PWM_MAX 1800   // PWMæœ€å¤§å€¼
#define TARGET_SPEED 1900    // åŸºç¡€ç›®æ ‡é€Ÿåº¦ï¼ˆç¼–ç å™¨å€¼ï¼‰
```

### 8. è°ƒè¯•åŠŸèƒ½

#### 8.1 ä¸²å£è¾“å‡º
- **æ³¢ç‰¹çŽ‡**: 115200
- **è¾“å‡ºå†…å®¹**:
  - å…‰ç”µä¼ æ„Ÿå™¨çŠ¶æ€ï¼ˆ12ä¸ªé€šé“ï¼‰
  - é™€èžºä»ªæ•°æ®ï¼ˆè§’é€Ÿåº¦ã€è§’åº¦ï¼‰
  - æŽ§åˆ¶åå·®
  - ç³»ç»ŸçŠ¶æ€ä¿¡æ¯

#### 8.2 è°ƒè¯•å‘½ä»¤
```c
// åœ¨mainå¾ªçŽ¯ä¸­å®šæœŸè¾“å‡º
printf("GyroZ: %.2f deg/s, Angle: %.2f deg, PhotoDev: %.2f\r\n", 
       gyro_z, integrated_angle, last_deviation);
```

### 9. ç¼–è¯‘ä¸Žçƒ§å½•

#### 9.1 å¼€å‘çŽ¯å¢ƒ
- **IDE**: STM32CubeIDE æˆ– Keil uVision
- **ç¼–è¯‘å™¨**: ARM GCC æˆ– ARMCC
- **è°ƒè¯•å™¨**: ST-Link æˆ– J-Link

#### 9.2 æž„å»ºæ­¥éª¤
1. å¯¼å…¥é¡¹ç›®åˆ°STM32CubeIDE
2. æ ¹æ®å®žé™…ç¡¬ä»¶è°ƒæ•´å¼•è„šé…ç½®
3. é…ç½®ç¼–è¯‘é€‰é¡¹
4. ç¼–è¯‘é¡¹ç›®
5. è¿žæŽ¥è°ƒè¯•å™¨çƒ§å½•ç¨‹åº

#### 9.3 å…³é”®é…ç½®
- **ç³»ç»Ÿæ—¶é’Ÿ**: 72MHz
- **å®šæ—¶å™¨**:
  - TIM1: PWMè¾“å‡ºï¼Œ10kHz
  - TIM2: æŽ§åˆ¶å‘¨æœŸï¼Œ1kHz
  - TIM3/TIM4: ç¼–ç å™¨æ¨¡å¼
- **SPI1**: BMI270é€šä¿¡ï¼Œ8MHz

### 10. æ€§èƒ½ä¼˜åŒ–

#### 10.1 å®žæ—¶æ€§ä¿è¯
- æŽ§åˆ¶å‘¨æœŸï¼š1msï¼ˆTIM2ä¸­æ–­ï¼‰
- ä¼ æ„Ÿå™¨é‡‡æ ·ï¼šä¸ŽæŽ§åˆ¶å‘¨æœŸåŒæ­¥
- ä½Žå»¶è¿Ÿå¤„ç†ï¼šä¸­æ–­å†…å®Œæˆæ‰€æœ‰æŽ§åˆ¶è®¡ç®—

#### 10.2 æ»¤æ³¢å¤„ç†
- å…‰ç”µä¼ æ„Ÿå™¨ï¼šæ•°å­—æ»¤æ³¢
- é™€èžºä»ªæ•°æ®ï¼šç§¯åˆ†è®¡ç®—
- ç¼–ç å™¨é€Ÿåº¦ï¼šå·®åˆ†è®¡ç®—

#### 10.3 ç¨³å®šæ€§æŽªæ–½
- ç§¯åˆ†é™å¹…ï¼šé˜²æ­¢ç§¯åˆ†é¥±å’Œ
- è¾“å‡ºé™å¹…ï¼šä¿æŠ¤ç”µæœºé©±åŠ¨
- å¼‚å¸¸å¤„ç†ï¼šä¼ æ„Ÿå™¨å¤±æ•ˆæ£€æµ‹

### 11. æ‰©å±•åŠŸèƒ½

#### 11.1 å¾…å®žçŽ°åŠŸèƒ½
1. **æ— çº¿é€šä¿¡**ï¼šæ·»åŠ è“ç‰™/WiFiæ¨¡å—
2. **å›¾åƒè¯†åˆ«**ï¼šé›†æˆæ‘„åƒå¤´æ¨¡å—
3. **è·¯å¾„è§„åˆ’**ï¼šå®žçŽ°é«˜çº§å¯¼èˆªç®—æ³•
4. **æ•°æ®è®°å½•**ï¼šSDå¡å­˜å‚¨è¿è¡Œæ•°æ®
5. **äººæœºäº¤äº’**ï¼šLCDæ˜¾ç¤ºå’ŒæŒ‰é”®æŽ§åˆ¶

#### 11.2 ä¼˜åŒ–æ–¹å‘
- è‡ªé€‚åº”PIDå‚æ•°è°ƒèŠ‚
- æœºå™¨å­¦ä¹ è·¯å¾„å­¦ä¹ 
- å¤šè½¦ååŒæŽ§åˆ¶
- è¿œç¨‹ç›‘æŽ§å’ŒæŽ§åˆ¶

### 12. æ•…éšœæŽ’é™¤

#### 12.1 å¸¸è§é—®é¢˜
1. **å°è½¦ä¸ç§»åŠ¨**
   - æ£€æŸ¥ç”µæœºé©±åŠ¨ç”µæº
   - éªŒè¯PWMè¾“å‡º
   - ç¡®è®¤æ–¹å‘æŽ§åˆ¶å¼•è„š

2. **å¾ªè¿¹ä¸ç¨³å®š**
   - è°ƒæ•´å…‰ç”µä¼ æ„Ÿå™¨é«˜åº¦
   - ä¼˜åŒ–PIDå‚æ•°
   - æ£€æŸ¥é™€èžºä»ªæ ¡å‡†

3. **é€šä¿¡å¼‚å¸¸**
   - æ£€æŸ¥ä¸²å£è¿žæŽ¥
   - éªŒè¯SPIé€šä¿¡æ—¶åº
   - ç¡®è®¤ä¼ æ„Ÿå™¨åˆå§‹åŒ–

#### 12.2 è°ƒè¯•å»ºè®®
1. å…ˆå•ç‹¬æµ‹è¯•æ¯ä¸ªä¼ æ„Ÿå™¨æ¨¡å—
2. ä½¿ç”¨ä¸²å£è¾“å‡ºç›‘æµ‹å…³é”®å˜é‡
3. é€æ­¥å¢žåŠ æŽ§åˆ¶å¤æ‚åº¦
4. è®°å½•å¹¶åˆ†æžè¿è¡Œæ•°æ®

### 13. è®¸å¯è¯

æœ¬é¡¹ç›®åŸºäºŽMITè®¸å¯è¯å¼€æºï¼Œå…è®¸è‡ªç”±ä½¿ç”¨ã€ä¿®æ”¹å’Œåˆ†å‘ï¼Œä½†éœ€ä¿ç•™åŽŸç‰ˆæƒå£°æ˜Žã€‚

### 14. è´¡çŒ®æŒ‡å—

æ¬¢è¿Žæäº¤Issueå’ŒPull Requestæ¥æ”¹è¿›é¡¹ç›®ã€‚è¯·ç¡®ä¿ï¼š
1. ä»£ç ç¬¦åˆçŽ°æœ‰é£Žæ ¼
2. æä¾›è¯¦ç»†çš„ä¿®æ”¹è¯´æ˜Ž
3. æµ‹è¯•é€šè¿‡åŽå†æäº¤

### 15. è‡´è°¢

- STMicroelectronics: æä¾›STM32 HALåº“
- Bosch Sensortec: BMI270ä¼ æ„Ÿå™¨
- æ‰€æœ‰ä¸ºæœ¬é¡¹ç›®æä¾›å¸®åŠ©çš„å¼€å‘è€…

---
*æ›´å¤šè¯¦ç»†ä¿¡æ¯è¯·å‚è€ƒä»£ç æ³¨é‡Šå’Œç¡¬ä»¶è®¾è®¡æ–‡æ¡£ã€‚å¦‚æœ‰é—®é¢˜ï¼Œè¯·æäº¤Issueæˆ–è”ç³»ç»´æŠ¤è€…ã€‚*
