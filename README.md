# STM32æ™ºèƒ½å¾ªè¿¹å°è½¦æ§åˆ¶ç³»ç»Ÿ

## ğŸ“œ é¡¹ç›®ç®€ä»‹
åŸºäºSTM32F103çš„é«˜æ€§èƒ½æ™ºèƒ½å¾ªè¿¹å°è½¦ï¼Œé‡‡ç”¨**å¤šä¼ æ„Ÿå™¨èåˆ**ä¸**ä¸‰çº§ä¸²çº§PIDæ§åˆ¶**æ¶æ„ï¼Œå®ç°äº†é«˜é€Ÿã€ç¨³å®šçš„å¾ªè¿¹åŠŸèƒ½ã€‚ç³»ç»Ÿé›†æˆäº†12è·¯å…‰ç”µä¼ æ„Ÿå™¨é˜µåˆ—ã€BMI270å…­è½´æƒ¯æ€§æµ‹é‡å•å…ƒ(IMU)ä»¥åŠé«˜ç²¾åº¦ç¼–ç å™¨ï¼Œèƒ½å¤Ÿåº”å¯¹å¤æ‚èµ›é“ï¼ˆå¦‚è™šçº¿ã€ç›´è§’å¼¯ã€Så¼¯ï¼‰ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### ç¡¬ä»¶æ¶æ„å›¾
ç³»ç»Ÿä»¥STM32F103C8T6ä¸ºæ ¸å¿ƒï¼Œé€šè¿‡å¤šè·¯å¤ç”¨å™¨è¯»å–ä¼ æ„Ÿå™¨é˜µåˆ—ï¼Œåˆ©ç”¨SPIæ¥å£è·å–é™€èºä»ªæ•°æ®ï¼Œå¹¶é€šè¿‡å®šæ—¶å™¨è¿›è¡Œç”µæœºé—­ç¯æ§åˆ¶ã€‚

```mermaid
graph TD
    MCU[STM32F103C8T6]
    
    subgraph Power_System [ç”µæºç³»ç»Ÿ]
        Bat[7.4V é”‚ç”µæ± ] --> Reg[ç¨³å‹æ¨¡å—]
        Reg --> MCU
        Bat --> MotorDriver
    end

    subgraph Sensors [ä¼ æ„Ÿå™¨å­ç³»ç»Ÿ]
        Photo[12è·¯å…‰ç”µä¼ æ„Ÿå™¨é˜µåˆ—] -->|æ¨¡æ‹Ÿ/æ•°å­—ä¿¡å·| MUX[16è·¯æ¨¡æ‹Ÿå¼€å…³/å¤šè·¯å¤ç”¨å™¨]
        MUX -->|å•çº¿æ•°æ®| MCU_GPIO_In[GPIOè¾“å…¥]
        MCU_GPIO_Out[4è·¯åœ°å€çº¿] -->|é€šé“é€‰æ‹©| MUX
        
        IMU[BMI270 6è½´é™€èºä»ª] -->|SPIæ€»çº¿| MCU_SPI[SPI1æ¥å£]
        
        EncL[å·¦ç”µæœºç¼–ç å™¨] -->|ABç›¸è„‰å†²| TIM4[TIM4 ç¼–ç å™¨æ¨¡å¼]
        EncR[å³ç”µæœºç¼–ç å™¨] -->|ABç›¸è„‰å†²| TIM3[TIM3 ç¼–ç å™¨æ¨¡å¼]
    end
    
    subgraph Actuators [æ‰§è¡Œæœºæ„]
        MCU_PWM[TIM1 PWMè¾“å‡º] -->|æ§åˆ¶ä¿¡å·| MotorDriver[åŒè·¯Hæ¡¥ç”µæœºé©±åŠ¨]
        MCU_Dir[GPIOæ–¹å‘æ§åˆ¶] -->|æ–¹å‘ä¿¡å·| MotorDriver
        MotorDriver --> MotorL[å·¦ç›´æµç”µæœº]
        MotorDriver --> MotorR[å³ç›´æµç”µæœº]
    end

    subgraph Debug [è°ƒè¯•æ¥å£]
        MCU_UART[USART3] -->|æ•°æ®é¥æµ‹| PC[ä¸Šä½æœº/ä¸²å£åŠ©æ‰‹]
    end
```

### è½¯ä»¶æ§åˆ¶æµå›¾
ç³»ç»Ÿé‡‡ç”¨1msçš„æ—¶é—´ç‰‡è½®è¯¢æ¶æ„ï¼Œåœ¨å®šæ—¶å™¨ä¸­æ–­ä¸­å®Œæˆæ‰€æœ‰æ§åˆ¶é€»è¾‘ï¼Œä¿è¯äº†æ§åˆ¶çš„å®æ—¶æ€§ã€‚

```mermaid
flowchart TD
    Start(("ç³»ç»Ÿå¯åŠ¨")) --> Init["ç¡¬ä»¶åˆå§‹åŒ–\n(GPIO, PWM, SPI, TIM)"]
    Init --> IMU_Init["BMI270é™€èºä»ªåˆå§‹åŒ–"]
    IMU_Init --> Loop["ä¸»å¾ªç¯\n(ä½ä¼˜å…ˆçº§ä»»åŠ¡)"]
    
    subgraph MainLoop [ä¸»å¾ªç¯]
        Debug["ä¸²å£æ•°æ®å‘é€\n(é¥æµ‹/è°ƒè¯•)"]
    end
    Loop --> MainLoop
    
    subgraph ISR ["TIM2å®šæ—¶å™¨ä¸­æ–­ (1kHz/1ms)"]
        Trigger["ä¸­æ–­è§¦å‘"] --> Get_IMU["è¯»å–é™€èºä»ªæ•°æ®\n(dodo_BMI270_get_data)"]
        Get_IMU --> Calc_Angle["è§’é€Ÿåº¦ç§¯åˆ† & å§¿æ€è§£ç®—"]
        
        Calc_Angle --> Get_Encoder["è¯»å–ç¼–ç å™¨\n(è®¡ç®—å®æ—¶é€Ÿåº¦)"]
        
        Get_Encoder --> Get_Line["è¯»å–å…‰ç”µä¼ æ„Ÿå™¨\n(MUXæ‰«æ12è·¯)"]
        Get_Line --> Calc_Dev["è®¡ç®—çº¿è·¯åå·®\n(åŠ æƒå¹³å‡ç®—æ³•)"]
        
        Calc_Dev --> PID_Pos["1. ä½ç½®ç¯/è½¬å‘ç¯ (PD)\nè¾“å…¥: çº¿è·¯åå·® â†’ è¾“å‡º: ç›®æ ‡è§’é€Ÿåº¦"]
        PID_Pos --> PID_Gyro["2. è§’é€Ÿåº¦ç¯ (PD)\nè¾“å…¥: ç›®æ ‡è§’é€Ÿåº¦ vs å®é™…è§’é€Ÿåº¦ â†’ è¾“å‡º: å·®é€Ÿè¡¥å¿"]
        
        PID_Gyro --> Mix["é€Ÿåº¦åˆ†é…\nBaseSpeed Â± å·®é€Ÿè¡¥å¿"]
        
        Mix --> PID_Speed["3. é€Ÿåº¦ç¯ (PI)\nè¾“å…¥: ç›®æ ‡é€Ÿåº¦ vs ç¼–ç å™¨é€Ÿåº¦ â†’ è¾“å‡º: PWM"]
        PID_Speed --> Motor_Out["ç”µæœºæ‰§è¡Œ"]
    end
```

## ğŸ§  æ ¸å¿ƒæ§åˆ¶åŸç†

æœ¬ç³»ç»Ÿé‡‡ç”¨äº†å…ˆè¿›çš„**ä¸‰çº§ä¸²çº§æ§åˆ¶ç­–ç•¥**ï¼Œç›¸æ¯”ä¼ ç»Ÿçš„å•ç¯PIDï¼Œå…·æœ‰æ›´å¼ºçš„æŠ—å¹²æ‰°èƒ½åŠ›å’ŒåŠ¨æ€å“åº”ç‰¹æ€§ã€‚

### 1. ä¼ æ„Ÿå™¨æ•°æ®å¤„ç†ç®—æ³•

#### å…‰ç”µä¼ æ„Ÿå™¨åŠ æƒå¹³å‡ä¸ç‰¹æ®Šå¤„ç†
ä¸ºäº†ä»ç¦»æ•£çš„12è·¯ä¼ æ„Ÿå™¨æ•°æ®ä¸­è·å–è¿ç»­çš„åå·®å€¼ï¼Œç³»ç»Ÿé‡‡ç”¨äº†åŠ æƒå¹³å‡ç®—æ³•ï¼Œå¹¶é’ˆå¯¹ç‰¹æ®Šè·¯å†µè¿›è¡Œäº†ä¼˜åŒ–ã€‚

- **åŠ æƒè®¡ç®—**ï¼šç»™æ¯ä¸ªä¼ æ„Ÿå™¨åˆ†é…æƒé‡ `weights = {11, 9, ..., -9, -11}`ã€‚
- **åå·®å…¬å¼**ï¼š

$$
Deviation = \frac{\sum (ActiveSensor_i \times Weight_i)}{\sum ActiveSensor_i}
$$
- **ç‰¹æ®Šè·¯å†µå¤„ç†**ï¼š
    - **ä¸¢çº¿å¤„ç†**ï¼šå½“æ‰€æœ‰ä¼ æ„Ÿå™¨å‡æœªæ£€æµ‹åˆ°çº¿æ—¶ï¼Œæ ¹æ®ä¸Šä¸€æ—¶åˆ»çš„åå·®å€¼ `last_deviation` é”å®šæœ€å¤§è½¬å‘è¾“å‡ºï¼ˆÂ±8.0ï¼‰ï¼Œå®ç°"è®°å¿†"åŠŸèƒ½ï¼Œé˜²æ­¢å†²å‡ºèµ›é“ã€‚
    - **æ€¥å¼¯å¢å¼º**ï¼šå½“æ£€æµ‹åˆ°åªæœ‰å•ä¾§ä¼ æ„Ÿå™¨è§¦å‘ï¼ˆå¦‚åªæœ‰æœ€å·¦ä¾§ï¼‰è€Œå¦ä¸€ä¾§å®Œå…¨æ— ä¿¡å·æ—¶ï¼Œäººä¸ºå¢åŠ åå·®è¡¥å¿ï¼ˆ`deviation Â± 1.5`ï¼‰ï¼Œæé«˜æ€¥å¼¯å“åº”é€Ÿåº¦ã€‚

#### é™€èºä»ªå§¿æ€è§£ç®—
- ä½¿ç”¨ `BMI270` è¯»å–Zè½´è§’é€Ÿåº¦ã€‚
- å¯¹è§’é€Ÿåº¦è¿›è¡Œç§¯åˆ†å¾—åˆ°å½“å‰çš„ç›¸å¯¹èˆªå‘è§’ `integrated_angle`ï¼Œç”¨äºè¾…åŠ©åˆ¤æ–­è½¦èº«å§¿æ€ã€‚

### 2. ä¸‰çº§ä¸²çº§PIDæ§åˆ¶ç³»ç»Ÿ

æ§åˆ¶ç³»ç»Ÿç”±å¤–è‡³å†…åˆ†ä¸ºä¸‰å±‚ï¼Œæ¯ä¸€å±‚çš„è¾“å‡ºä½œä¸ºä¸‹ä¸€å±‚çš„è¾“å…¥ï¼š

1.  **æœ€å¤–å±‚ï¼šè½¬å‘ç¯ (Position Loop)**
    *   **ç›®æ ‡**ï¼šä½¿å°è½¦å§‹ç»ˆä¿æŒåœ¨çº¿è·¯ä¸­å¿ƒï¼ˆåå·®ä¸º0ï¼‰ã€‚
    *   **è¾“å…¥**ï¼šå…‰ç”µä¼ æ„Ÿå™¨è®¡ç®—å‡ºçš„åå·®å€¼ã€‚
    *   **ç®—æ³•**ï¼šPDæ§åˆ¶ï¼ˆæ¯”ä¾‹+å¾®åˆ†ï¼‰ã€‚
    *   **è¾“å‡º**ï¼š**ç›®æ ‡è§’é€Ÿåº¦ (Target Gyro Rate)**ã€‚
    *   *åŸç†*ï¼šåå·®è¶Šå¤§ï¼Œå°è½¦éœ€è¦çš„è½¬å‘è§’é€Ÿåº¦å°±è¶Šå¤§ã€‚

2.  **ä¸­é—´å±‚ï¼šè§’é€Ÿåº¦ç¯ (Angular Rate Loop)**
    *   **ç›®æ ‡**ï¼šè®©å°è½¦å®é™…çš„è½¬å‘å¿«æ…¢ï¼ˆè§’é€Ÿåº¦ï¼‰ç²¾å‡†è·Ÿéšç›®æ ‡è§’é€Ÿåº¦ã€‚
    *   **è¾“å…¥**ï¼šç›®æ ‡è§’é€Ÿåº¦ - å®é™…è§’é€Ÿåº¦ï¼ˆé™€èºä»ªZè½´æ•°æ®ï¼‰ã€‚
    *   **ç®—æ³•**ï¼šPDæ§åˆ¶ã€‚
    *   **è¾“å‡º**ï¼š**å·¦å³ç”µæœºå·®é€Ÿè¡¥å¿å€¼**ã€‚
    *   *åŸç†*ï¼šåˆ©ç”¨é™€èºä»ªçš„é«˜é¢‘å“åº”ç‰¹æ€§ï¼Œå¿«é€Ÿä¿®æ­£è½¦èº«å§¿æ€ï¼ŒæŠ‘åˆ¶è½¬å‘æ—¶çš„éœ‡è¡ï¼ˆå¦‚Så¼¯ä¸­çš„ç”©å°¾ï¼‰ã€‚

3.  **æœ€å†…å±‚ï¼šé€Ÿåº¦ç¯ (Speed Loop)**
    *   **ç›®æ ‡**ï¼šè®©ç”µæœºè½¬é€Ÿæ’å®šï¼Œå…‹æœæ‘©æ“¦åŠ›å’Œç”µæ± ç”µå‹æ³¢åŠ¨ã€‚
    *   **è¾“å…¥**ï¼šç›®æ ‡é€Ÿåº¦ï¼ˆåŸºç¡€é€Ÿåº¦ Â± å·®é€Ÿè¡¥å¿ï¼‰ - ç¼–ç å™¨åé¦ˆé€Ÿåº¦ã€‚
    *   **ç®—æ³•**ï¼šPIæ§åˆ¶ï¼ˆæ¯”ä¾‹+ç§¯åˆ†ï¼‰ã€‚
    *   **è¾“å‡º**ï¼š**ç”µæœºPWMå ç©ºæ¯”**ã€‚
    *   *åŸç†*ï¼šç§¯åˆ†é¡¹ä¿è¯äº†ç¨³æ€æ— è¯¯å·®ï¼Œä½¿å°è½¦åœ¨ä¸Šå¡æˆ–ä½ç”µé‡æ—¶ä»èƒ½ä¿æŒè®¾å®šé€Ÿåº¦ã€‚

## ğŸ’» å…³é”®ä»£ç è§£æ

### 1. å®šæ—¶å™¨ä¸­æ–­è§¦å‘æ§åˆ¶å‘¨æœŸ
```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM2) { /* ä½¿ç”¨TIM2ä½œä¸ºæ§åˆ¶å‘¨æœŸ*/
        PID_Control();
    }
}
```
- **é¢‘ç‡**: 1kHzï¼ˆTIM2é…ç½®ï¼šé¢„åˆ†é¢‘71ï¼Œå‘¨æœŸ999ï¼‰
- **ä½œç”¨**: æ¯1msæ‰§è¡Œä¸€æ¬¡å®Œæ•´çš„PIDæ§åˆ¶å¾ªç¯

### 2. ä¸»PIDæ§åˆ¶æµç¨‹ (main.c)
```c
void PID_Control(void)
{
    /* æ­¥éª¤1: è¯»å–ä¼ æ„Ÿå™¨æ•°æ® */
    Update_Gyro_Data();                    // æ›´æ–°é™€èºä»ªæ•°æ®
    float current_deviation = Calculate_Deviation();  // è®¡ç®—å…‰ç”µåå·®
    
    /* æ­¥éª¤2: è¯»å–ç¼–ç å™¨å€¼ */
    left_encoder = __HAL_TIM_GET_COUNTER(&htim4);
    right_encoder = __HAL_TIM_GET_COUNTER(&htim3);
    
    /* æ­¥éª¤3: è½¬å‘ç¯æ§åˆ¶ */
    float turn_output = KP_turn * current_deviation + 
                       KD_turn * (current_deviation - last_deviation);
    last_deviation = current_deviation;
    
    /* æ­¥éª¤4: è§’é€Ÿåº¦ç¯æ§åˆ¶ */
    target_gyro_rate = turn_output;  // è½¬å‘ç¯è¾“å‡ºä½œä¸ºç›®æ ‡è§’é€Ÿåº¦
    float gyro_output = Gyro_Rate_Control(target_gyro_rate, gyro_z);
    
    /* æ­¥éª¤5: é€Ÿåº¦åˆ†é… */
    float left_target = 500.0f - gyro_output;  // åŸºç¡€é€Ÿåº¦500ï¼Œå®é™…éœ€è°ƒæ•´
    float right_target = 500.0f + gyro_output;
    
    /* æ­¥éª¤6: é€Ÿåº¦ç¯æ§åˆ¶ */
    // ç¼–ç å™¨å·®å€¼è®¡ç®—é€Ÿåº¦ï¼ˆç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è®¡ç®—çœŸå®é€Ÿåº¦ï¼‰
    float left_error = left_target - left_speed;
    float right_error = right_target - right_speed;
    
    left_integral += left_error;    // ç§¯åˆ†é¡¹
    right_integral += right_error;
    
    // ç§¯åˆ†é™å¹…
    if(left_integral > 1000) left_integral = 1000;
    if(left_integral < -1000) left_integral = -1000;
    if(right_integral > 1000) right_integral = 1000;  
    if(right_integral < -1000) right_integral = -1000;
    
    /* æ­¥éª¤7: è®¡ç®—PWMè¾“å‡º */
    left_pwm = KP_speed * left_error + KI_speed * left_integral;
    right_pwm = KP_speed * right_error + KI_speed * right_integral;
    
    /* æ­¥éª¤8: é©±åŠ¨ç”µæœº */
    Motor_Control(left_pwm, right_pwm);
}
```

### 3. ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†æµç¨‹

#### 3.1 å…‰ç”µä¼ æ„Ÿå™¨æ•°æ®è·å–
```c
float Calculate_Deviation(void)
{
    uint16_t mux_value;
    MUX_get_value(&mux_value);  // è·å–å¤šè·¯å¤ç”¨å™¨å€¼
    
    float deviation = 0;
    int count = 0;
    
    /* éå†12ä¸ªå…‰ç”µç®¡ */
    for(int i = 0; i < 12; i++) {
        if(MUX_GET_CHANNEL(mux_value, i)) {
            deviation += phototube_weights[i];  // åŠ æƒæ±‚å’Œ
            count++;
        }
    }
    
    /* å¤„ç†ä¸åŒæƒ…å†µ */
    if(count > 0) {
        deviation = deviation / count;  // è®¡ç®—å¹³å‡åå·®
    } else {
        /* ä¸¢çº¿å¤„ç† */
        if(last_deviation > 3.0f) deviation = 8.0f;
        else if(last_deviation < -3.0f) deviation = -8.0f;
        else deviation = -8.0f;
    }
    
    /* é™åˆ¶åå·®èŒƒå›´ */
    if(deviation > 11.0f) deviation = 11.0f;
    if(deviation < -11.0f) deviation = -11.0f;
    
    return deviation;
}
```

#### 3.2 é™€èºä»ªæ•°æ®æ›´æ–°
```c
void Update_Gyro_Data(void)
{
    /* è¯»å–åŸå§‹æ•°æ® */
    dodo_BMI270_get_data();
    
    /* è½¬æ¢ä¸ºè§’é€Ÿåº¦ */
    gyro_z = BMI270_gyro_transition(BMI270_gyro_z);
    
    /* ç§¯åˆ†è®¡ç®—è§’åº¦ */
    uint32_t current_time = HAL_GetTick();
    if(last_gyro_time > 0) {
        float dt = (current_time - last_gyro_time) / 1000.0f;
        integrated_angle += gyro_z * dt;
        
        /* è§’åº¦é™å¹… */
        if(integrated_angle > 180.0f) integrated_angle = 180.0f;
        if(integrated_angle < -180.0f) integrated_angle = -180.0f;
    }
    last_gyro_time = current_time;
}
```

## âš™ï¸ ç¡¬ä»¶è§„æ ¼

| æ¨¡å— | å‹å·/å‚æ•° | ä½œç”¨ |
| :--- | :--- | :--- |
| **ä¸»æ§èŠ¯ç‰‡** | STM32F103C8T6 | 72MHzä¸»é¢‘ï¼Œå¤„ç†æ ¸å¿ƒç®—æ³• |
| **å§¿æ€ä¼ æ„Ÿå™¨** | BMI270 | 16-bit é™€èºä»ªï¼Œæä¾›é«˜ç²¾åº¦è§’é€Ÿåº¦åé¦ˆ |
| **å¾ªè¿¹æ¨¡å—** | è‡ªç ”12è·¯çº¢å¤–å¯¹ç®¡ | é…åˆ74HC4067å¤šè·¯å¤ç”¨å™¨è¯»å– |
| **ç”µæœºé©±åŠ¨** | åŒè·¯Hæ¡¥é©±åŠ¨ | æ”¯æŒå¤§ç”µæµï¼ŒPWMé¢‘ç‡10kHz |
| **ç”µæº** | 2S é”‚ç”µæ±  (7.4V) | ä¸ºç”µæœºå’ŒLDOä¾›ç”µ |

## ğŸš€ å¿«é€Ÿå¼€å§‹

1.  **ç¯å¢ƒå‡†å¤‡**: å®‰è£… STM32CubeIDE æˆ– Keil MDKã€‚
2.  **ç¡¬ä»¶è¿æ¥**: 
    - ç¡®ä¿ç”µæ± ç”µå‹å……è¶³ (>7.0V)ã€‚
    - æ£€æŸ¥ç”µæœºçº¿åºæ˜¯å¦æ­£ç¡®ï¼ˆå½±å“æ­£åè½¬ï¼‰ã€‚
3.  **å‚æ•°æ•´å®š**:
    - ä¼˜å…ˆè°ƒèŠ‚ `KP_speed` å’Œ `KI_speed` ä¿è¯é€Ÿåº¦ç¨³å®šã€‚
    - è°ƒèŠ‚ `KP_turn` ç›´åˆ°å°è½¦èƒ½å¤§è‡´æ²¿çº¿èµ°ã€‚
    - åŠ å…¥ `KP_gyro` æŠ‘åˆ¶å¿«é€Ÿè¿‡å¼¯æ—¶çš„éœ‡è¡ã€‚
4.  **è°ƒè¯•**: è¿æ¥ä¸²å£ (æ³¢ç‰¹ç‡115200)ï¼ŒæŸ¥çœ‹è¾“å‡ºçš„ `GyroZ` å’Œ `PhotoDev` æ•°æ®æ³¢å½¢ã€‚

---
*Project maintained by HITSZ Mini-Car Team*
